; Automatically generated by make_idl_types.pl
; Extracted from simu_params.par
; 120914_15:56:16


pro , str


;; Init str
str = create_struct("date", '120914_15:56:16')
; parametres de l'ama
str = create_struct( str, "P0_clust", 100e-11) ; Pression electronique au centre de l'amas (en Pa)
str = create_struct( str, "a_clust", 0.9) ; Parametrisation universelle de pression (chandra: 0.9)
str = create_struct( str, "b_clust", 5.0) ; Parametrisation universelle de pression (chandra: 5)
str = create_struct( str, "c_clust", 0.4) ; Parametrisation universelle de pression (chandra: 0.4)
str = create_struct( str, "rc_clust", 500.0) ; Parametrisation universelle de pression (en kpc)
str = create_struct( str, "thetac_clust", 20.0) ; Taille angulaire de l'amas (en arcsec)
str = create_struct( str, "T_planet", 1.0) ; Temperature d'antenne de la planete en K_RJ a nu1, ~1K pour Uranus
;;;;;;;;;;;;;;;;;;;;; parametres du scan ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
str = create_struct( str, "Taille_carte", 300.0) ; Taille de la carte (en arcsec)
str = create_struct( str, "Taille_nika", 120.0) ; Taille angulaire de nika dans le plan focal (en arcsec)
str = create_struct( str, "Taille_step", 3.0) ; Taille angulaire du pas de scan selon la verticale
str = create_struct( str, "Vitesse_scan", 8.25) ; Vitesse du scan en degres par seconde
str = create_struct( str, "nu1", 140.0) ; Frequence d'observation 1 (en GHz)
str = create_struct( str, "nu2", 220.0) ; Frequence d'observation 2 (en GHz)
str = create_struct( str, "N_sky", 4000) ; Nombre de pixels sur la longueur de la carte
str = create_struct( str, "N_ip", 8) ; Nombre de points sur lesquelles on interpol la carte scannée faute de memoire du laptop (N_sky
str = create_struct( str, "N_kid", 81) ; Nombre de detecteurs
str = create_struct( str, "freq_ech", 880.0) ; Frequence d'echantillonage en Hz pour les données elementaires
str = create_struct( str, "Taille_lobe", 15.0) ; Taille du lobe (en arcsec, FWHM)
;;;;;;;;;;;;;;;;;;;;; parametres du bruit ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
str = create_struct( str, "T_back", 30.0) ; Temperature du background en K
str = create_struct( str, "T_CMB", 2.735) ; Temperature du CMB
str = create_struct( str, "prop", -1e3) ; Facteur de proportionalité entre temperature et deltaf_0 en Hz/K_rj
str = create_struct( str, "alpha", -1.6) ; Pente du bruit A*k^alpha atmospherique
str = create_struct( str, "beta_dec", 0.0) ; Pente du bruit de kid decorrelé
str = create_struct( str, "beta_cor", -0.6) ; Pente du bruit electronique
str = create_struct( str, "f_ref", 1.0) ; Frequence de reference pour le spectre bruité (arbitraire)
str = create_struct( str, "T_fluc", 200e-6) ; Fluctuation du background (en K/Hz^0.5) à f_ref d'apres l'article
str = create_struct( str, "T_kid_dec", 2.0) ; Bruit de kid non correlé (en Hz/Hz^0.5) <
str = create_struct( str, "T_kid_cor", 250e-6) ; Bruit de kid corrélé à f_ref (en K/Hz^0.5): 2.5e-3
str = create_struct( str, "", )
;;;;;;;;;;;;;;;;;;;;; parametres des KIDs ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
str = create_struct( str, "df", 2000.0) ; Difference de frequence injectée entre deux points (en Hz)
str = create_struct( str, "N_moy", 40) ; Nombre d'echantillon sur lequel on moyenne les resultats
;  fkid_0 = 1.5d9 + dindgen(N_kid)*0.5d6 ;Peigne des frequences de resonance espacés de 0.5 MHz
str = create_struct( str, "Z_0", 50.0) ; Voir la modelisation des KIDs
str = create_struct( str, "Q_i", 2e5) ; On suppose ici que les facteurs de qualité de changent pas
str = create_struct( str, "Q_e", 5e4) ; en fonction de la puissance optique,
str = create_struct( str, "X_1", 3.0) ; et que tous les KIDs sont identiques.
str = create_struct( str, "X_2", 3.0) ; De même pour les impedances X_1 X_2
;;;;;;;;;;;;;;;;;;;;; changement d'unité ;;;;;;;;;;;;;;;;;;;;
;  rc_clust = rc_clust*3.08568e19           ;rc_clust en metre
;  thetac_clust = thetac_clust/3600.0       ;thetac_clust en degres
;  Taille_carte = Taille_carte/3600.0       ;Taille_carte en degres
;  Taille_nika = Taille_nika/3600.0         ;Taille_nika en degres
;  Taille_step = Taille_step/3600.0         ;Taille_step en degres
;  Vitesse_scan = Vitesse_scan/3600.0       ;Vitesse_scan en degres
;  nu1 = nu1*1e9                            ;Frequence en Hertz
;  nu2 = nu2*1e9                            ;Frequence en Hertz  
;  Taille_lobe = Taille_lobe/2.35482/3600.0 ;Lobe en degres (FWHM = 2.35482 sigma)
;  T_kid_dec = T_kid_dec/prop               ;T_kid_dec en K/Hz^0.5
;;;;;;;;;;;;;;;;;;;;; parametres additionnelles calculés automatiquement;;;;;;;;;;;;;;;;;;;;
;  Taille_pix = Taille_carte/N_sky                                                    ;Taille en degres d'un pixel = taille_deg_carte/N_skyx
;  dist_pix = rc_clust*Taille_pix/thetac_clust                                        ;distance correspondant a 1 pixel en m au niveau de l'amas
;  if (N_kid eq 1) then d_kid=1l else d_kid = Taille_nika/(sqrt(N_kid)-1l)/Taille_pix ;Distance entre les kids en pixel
;  x_planet = N_sky/2                                                                 ;position de la planete/amas (pixel)
;  y_planet = N_sky/2                                                                 ;position de la planete/amas (pixel)
;  delta_scan = Taille_step/Taille_pix                                                ;ecart deltaY entre les deux aller retour du scan 
;  lobe = Taille_lobe/Taille_pix                                                      ;Rayon du lobe en pixel sur le ciel = taille_deg/taille_pix
;  fact_sample = Vitesse_scan/freq_ech/Taille_pix*N_ip                                ;nombre de pixel par sampling
;
;  ;dT_rj = (h nu/k/T_cmb)^2 * exp(h nu/T_cmb/k)/(exp(h nu/T_cmb/k)-1)^2 * dT_cmb
;  prop1 = prop /( (4.799238e-11*nu1/2.725)^2.0 * exp(4.799238e-11*nu1/2.725) / (exp(4.799238e-11*nu1/2.725)-1.0)^2.0 ) ;prop convertit en Hz/Tcmb à nu1
;  prop2 = prop /( (4.799238e-11*nu2/2.725)^2.0 * exp(4.799238e-11*nu2/2.725) / (exp(4.799238e-11*nu2/2.725)-1.0)^2.0 ) ;prop convertit en Hz/Tcmb à nu2
;;;;;;;;;;;;;;;;;;;;; information sur la validité des paramètres ;;;;;;;;;;;;;;;;;;;;
;  if keyword_set(aff) then begin
;     print, ' '
;     print, '----------                      ATTENTION                      ----------'
;     print, '                                   /\                '
;     print, '                                  /  \               '
;     print, '                                 /    \              '
;     print, '                                /  |   \             '
;     print, '                               /   |    \            '
;     print, '                              /    .     \           '
;     print, '                             /____________\          '
;     print, '                                                     '
;     print, '----------  Verifiez que les parametres suivants sont entiers  ----------'
;     print, '----------     pour assurer le bon fonctionnement du code.     ----------'
;     print, '-------------------------------------------------------------------------'
;     print, 'Distance entre les KIDs en pixels sur la carte: ', d_kid
;     print, 'Pas de scan vertical en pixel sur la carte: ', delta_scan
;     print, 'Pas de scan horizontal en pixel sur la carte: ', fact_sample
;     print, 'N_moy doit etre pair: ', N_moy
;     print, 'Le nombre de kid doit etre un carre parfait: sqrt(N_kid) = ', sqrt(N_kid)
;     print, '-------------------------------------------------------------------------'
;     print, ' '
;  endif
;  x_planet = round(x_planet)       ;position de la planete/amas (pixel)
;  y_planet = round(y_planet)       ;position de la planete/amas (pixel)
;  delta_scan = round(delta_scan)   ;ecart deltaY entre les deux aller retour du scan 
;  fact_sample = round(fact_sample) ;nombre de pixel par sampling
;
;end


end


end


end
